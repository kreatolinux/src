.\" Automatically generated by Pandoc 3.1.3
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "kongue" "5" "" "" ""
.hy
.SH NAME
.PP
Kongue - Scripting langauge of Kreato Linux
.SH DESCRIPTION
.PP
Kongue is the main scripting language made for use in Kreato Linux
projects.
It is inspired by YAML and sh among many other languages.
It is currently used by kpkg as the main package format (see kpkg_run(5)
for specific details).
.SH KONGUE STRUCTURE
.PP
Kongue scripts don\[cq]t have a global file extension, though
\f[V].kg\f[R] or \f[V].kongue\f[R] might be used.
.SS Example Kongue script
.IP
.nf
\f[C]
global_var_string: \[dq]test\[dq]
global_var_bool: true
global_var_array:
    - \[dq]hello\[dq]
    - \[dq]test\[dq]
    - \[dq]test2\[dq]

func custom_func {
    print \[dq]This is a test custom function, hello $1\[dq]
}

# Different projects will have different main functions, such as build for kpkg_run(5). This is just an example.
main { 
    custom_func \[dq]Kreato\[dq] # Can run custom functions just like commands
    print \[dq]Test\[dq]
    exec \[dq]command -v bash\[dq]
}
\f[R]
.fi
.SH SYNTAX AND LANGUAGE FEATURES
.SS VARIABLES
.PP
Variables must be declared at the top of the script.
They can be any type (list, string, int, bool, etc.).
Variables can be referenced in if statements, for loops, and inside
functions.
On commands, simple referencing is done via \f[V]$variable\f[R] or
\f[V]${variable}\f[R].
Complex manipulation (splitting, slicing) works via
\f[V]${variable.method()}\f[R] (or \f[V]variable.method()\f[R] on a
non-command context) (see \f[B]VARIABLE MANIPULATION\f[R] below).
.IP
.nf
\f[C]
test1: true
test2:
    - this is a test
    - test2
# and so on...
\f[R]
.fi
.PP
Variables can be referenced in if statements, for loops, inside
variables, and inside functions (including in commands).
.IP
.nf
\f[C]
test1: true

# Additional stuff...

echo $test1
# Result: true
\f[R]
.fi
.PP
List variables can be filtered using \f[V][start:end]\f[R] and can be
indexed using \f[V][index]\f[R].
Note that this cannot be used with the \f[V]$variable\f[R] syntax, only
inside \f[V]${variable}\f[R].
See the example below.
.IP
.nf
\f[C]
test2:
    - IGNORE1
    - IGNORE2
    - IGNORE3

echo ${test2[0:3].join(\[aq]\[aq])}
# Result: IGNORE1IGNORE2IGNORE3

echo ${test2[0]}
# Result: IGNORE1
\f[R]
.fi
.SS IF ELSE STATEMENTS
.PP
If-else statements can be used inside all functions.
You can utilize all variables defined in the script.
.IP
.nf
\f[C]
build {
    if test1 {
        print hello!
    } else {
        print bye!
    }
}   
\f[R]
.fi
.PP
You can also use any variable manipulation methods in if statements,
including inline exec to execute commands and use their output or exit
code in conditions.
See \f[B]VARIABLE MANIPULATION\f[R] for details on available methods.
.SS CONDITION OPERATORS
.PP
The following operators are supported in conditions:
.IP \[bu] 2
\f[B]==\f[R] (equality):
\f[V]if \[dq]$var\[dq] == \[dq]value\[dq] { ... }\f[R]
.IP \[bu] 2
\f[B]!=\f[R] (inequality):
\f[V]if \[dq]$var\[dq] != \[dq]value\[dq] { ... }\f[R]
.IP \[bu] 2
\f[B]=\[ti]\f[R] (regex match):
\f[V]if \[dq]$var\[dq] =\[ti] e\[dq]pattern\[dq] { ... }\f[R]
.IP \[bu] 2
\f[B]||\f[R] (OR):
\f[V]if \[dq]$var\[dq] == \[dq]a\[dq] || \[dq]$var\[dq] == \[dq]b\[dq] { ... }\f[R]
.IP \[bu] 2
\f[B]&&\f[R] (AND):
\f[V]if \[dq]$var1\[dq] == \[dq]a\[dq] && \[dq]$var2\[dq] == \[dq]b\[dq] { ... }\f[R]
.SS REGEX MATCHING
.PP
Use the \f[V]=\[ti]\f[R] operator with \f[V]e\[dq]pattern\[dq]\f[R]
syntax for regex matching.
The pattern uses standard regex syntax with \f[V]|\f[R] for
alternatives.
.IP
.nf
\f[C]
package {
    for APPLET in applets {
        # Skip applets provided by other packages
        if \[dq]$APPLET\[dq] =\[ti] e\[dq]clear|grep|egrep|fgrep|tar|bzip2\[dq] {
            continue
        }
        exec \[dq]ln -s /bin/busybox $ROOT/bin/$APPLET\[dq]
    }
}
\f[R]
.fi
.SS COMBINING CONDITIONS
.PP
You can combine multiple conditions using \f[V]||\f[R] (OR) and
\f[V]&&\f[R] (AND):
.IP
.nf
\f[C]
build {
    # OR: true if any condition is true
    if \[dq]$ARCH\[dq] == \[dq]x86_64\[dq] || \[dq]$ARCH\[dq] == \[dq]amd64\[dq] {
        print \[dq]Building for 64-bit x86\[dq]
    }
    
    # AND: true only if all conditions are true
    if \[dq]$DEBUG\[dq] == \[dq]true\[dq] && \[dq]$VERBOSE\[dq] == \[dq]true\[dq] {
        print \[dq]Debug mode with verbose output\[dq]
    }
}
\f[R]
.fi
.SS VARIABLE MANIPULATION
.PP
Variables can be manipulated directly within strings using object-style
methods.
This is particularly useful for constructing source URLs that require
specific version formatting (e.g., extracting \[lq]Major.Minor\[rq] from
a full version string).
You can also use inline exec to execute commands and use their output or
exit code.
.PP
The syntax for manipulation is \f[V]${variable.method(arguments)}\f[R]
or \f[V]${exec(\[dq]command\[dq]).method()}\f[R].
.PP
\f[B]Note\f[R]: Global variables (defined at the top of the kongue
script) cannot use exec directly.
Exec can only be used within function blocks (like \f[V]build\f[R],
\f[V]prepare\f[R], \f[V]package\f[R], etc.)
or inside custom functions.
.SS AVAILABLE METHODS
.IP \[bu] 2
\f[B]join(delimiter)\f[R] Joins a list into a string using the given
delimiter.
Only works with lists.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]2.78.1\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq]).join(\[aq]!\[aq])}\f[R] returns
\f[V]2!78!1\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[0:2].join(\[aq].\[aq])}\f[R] returns
\f[V]2.78\f[R]
.RE
.IP \[bu] 2
\f[B]split(delimiter)\f[R] Splits the string by the given delimiter and
returns the segments as a list.
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]2.78.1\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[0]}\f[R] returns \f[V]2\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[1]}\f[R] returns \f[V]78\f[R]
.RE
.IP \[bu] 2
\f[B]cut(start, end)\f[R] Slices the string from the \f[V]start\f[R]
index up to (but not including) the \f[V]end\f[R] index.
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]commit: \[dq]543ee30eda80...\[dq]\f[R]
.IP \[bu] 2
\f[V]${commit.cut(0, 7)}\f[R] returns \f[V]543ee30\f[R]
.RE
.IP \[bu] 2
\f[B]replace(old, new)\f[R] Replaces all occurrences of \f[V]old\f[R]
substring with \f[V]new\f[R].
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]1.0.5\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.replace(\[aq].\[aq], \[aq]_\[aq])}\f[R] returns
\f[V]1_0_5\f[R]
.RE
.IP \[bu] 2
\f[B]exec(command).output()\f[R] Executes a shell command and returns
its output.
Can be used in conditionals, variable assignments, and string
interpolation.
Only works within function blocks, not in global variable definitions.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R]
\f[V]build { if ${exec(\[dq]test -f config.h\[dq]).output()} { print \[dq]config.h exists\[dq] } }\f[R]
.IP \[bu] 2
\f[V]${exec(\[dq]ls -1 | head -n 1\[dq]).output()}\f[R] returns the
first line of directory listing
.RE
.IP \[bu] 2
\f[B]exec(command).exit()\f[R] Executes a shell command and returns its
exit code (0 for success, non-zero for failure).
Can be used in conditionals and comparisons.
Only works within function blocks, not in global variable definitions.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R]
\f[V]build { if ${exec(\[dq]test -f config.h\[dq]).exit()} == 0 { print \[dq]config.h exists\[dq] } }\f[R]
.IP \[bu] 2
\f[V]${exec(\[dq]ls nonexistent\[dq]).exit()}\f[R] returns a non-zero
exit code if the file doesn\[cq]t exist
.RE
.SS EXAMPLES
.PP
Combining methods to construct complex URLs:
.IP
.nf
\f[C]
version: \[dq]2.78.1\[dq]
sources:
    - \[dq]https://download.acme.org/sources/acme/${version.split(\[aq].\[aq])[0:2].join(\[aq].\[aq])}/acme-$version.tar.xz\[dq]
\f[R]
.fi
.PP
Using inline exec in conditionals and variable assignments:
.IP
.nf
\f[C]
build {
    if ${exec(\[dq]test -f config.h\[dq]).exit()} == 0 {
        print \[dq]config.h exists\[dq]
    }
    
    local first_file = ${exec(\[dq]ls -1 | head -n 1\[dq]).output()}
    print \[dq]First file: $first_file\[dq]
}
\f[R]
.fi
.SS FOR LOOPS
.PP
For loops can be used inside all functions.
You can access all variables defined in the script.
.IP
.nf
\f[C]
build {
    for i in test2 {
        print $i
    }
}
\f[R]
.fi
.PP
You can also use inline list literals directly in for loops:
.IP
.nf
\f[C]
package {
    for file in [\[dq]tzselect\[dq], \[dq]zdump\[dq], \[dq]zic\[dq]] {
        exec \[dq]rm -f $ROOT/usr/bin/$file\[dq]
    }
}
\f[R]
.fi
.SS VARIABLE EXPRESSIONS IN FOR LOOPS
.PP
For loops support variable expressions that resolve to lists.
This is useful when iterating over dynamic content like command output:
.IP
.nf
\f[C]
package {
    # Iterate over lines from command output
    for APPLET in \[dq]${exec(\[rs]\[dq]$ROOT/bin/busybox --list\[rs]\[dq]).output()}\[dq] {
        print \[dq]Processing applet: $APPLET\[dq]
    }
    
    # Iterate over a variable that contains newline-separated values
    local items: \[dq]${exec(\[rs]\[dq]ls -1\[rs]\[dq]).output()}\[dq]
    for item in \[dq]$items\[dq] {
        print \[dq]Item: $item\[dq]
    }
}
\f[R]
.fi
.SS LOOP CONTROL: CONTINUE AND BREAK
.PP
Use \f[V]continue\f[R] to skip to the next iteration and \f[V]break\f[R]
to exit the loop entirely:
.IP
.nf
\f[C]
package {
    for APPLET in applets {
        # Skip certain applets
        if \[dq]$APPLET\[dq] =\[ti] e\[dq]grep|tar|bzip2\[dq] {
            continue
        }
        
        # Stop processing if we hit a specific applet
        if \[dq]$APPLET\[dq] == \[dq]STOP\[dq] {
            break
        }
        
        exec \[dq]ln -s /bin/busybox $ROOT/bin/$APPLET\[dq]
    }
}
\f[R]
.fi
.SS BUILTIN COMMANDS
.PP
These are the built-in commands available in all kongue environments:
.IP \[bu] 2
\f[B]exec\f[R]: Spawn shell commands.
Usage: \f[V]exec [COMMAND]\f[R]
.IP \[bu] 2
\f[B]print\f[R]: Print output to stdout.
Usage: \f[V]print [STRING]\f[R]
.IP \[bu] 2
\f[B]cd\f[R]: Change directory.
Usage: \f[V]cd [DIRECTORY]\f[R]
.IP \[bu] 2
\f[B]echo\f[R]: Alias to \f[V]print\f[R].
Usage: \f[V]echo [STRING]\f[R]
.IP \[bu] 2
\f[B]local\f[R]: Allows you to set a local variable inside a function
(see CUSTOM FUNCTIONS).
Usage: \f[V]local [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]global\f[R]: Allows you to set and override a global variable
inside a function (see CUSTOM FUNCTIONS).
Usage: \f[V]global [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]env\f[R]: Allows you to set and override environment variables
inside a function.
Usage: \f[V]env [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]write\f[R]: Write content to a file.
Overwrites the file if it exists.
Usage: \f[V]write [FILE] [STRING]\f[R]
.IP \[bu] 2
\f[B]append\f[R]: Append content to a file.
Creates the file if it does not exist.
Usage: \f[V]append [FILE] [STRING]\f[R]
.IP \[bu] 2
\f[B]continue\f[R]: Skip to the next iteration in a for loop.
Usage: \f[V]continue\f[R]
.IP \[bu] 2
\f[B]break\f[R]: Exit from a for loop immediately.
Usage: \f[V]break\f[R]
.PP
See \f[B]STRINGS\f[R] for information on multi-line content.
.PP
The rest of the shell commands (should you need them) can only be
accessed using the \f[V]exec\f[R] parameter.
.SS STRINGS
.PP
Strings can be enclosed in double quotes (\f[V]\[dq]\f[R]) or single
quotes (\f[V]\[aq]\f[R]).
.PP
For multi-line strings, use triple quotes (\f[V]\[dq]\[dq]\[dq]\f[R]).
.IP
.nf
\f[C]
write \[dq]file.txt\[dq] \[dq]\[dq]\[dq]
Line 1
Line 2
\[dq]\[dq]\[dq]
\f[R]
.fi
.SH VARIABLES AND FUNCTIONS
.SS CUSTOM FUNCTIONS
.PP
Users can define their own reusable functions to avoid repetition.
These function blocks follow the same syntax as lifecycle functions
(like \f[V]build\f[R] or \f[V]prepare\f[R]) but require the
\f[V]func\f[R] keyword.
.SS SYNTAX
.PP
Custom functions are defined at the top level of the script.
They use standard POSIX-like shell argument handling (\f[V]$1\f[R],
\f[V]$2\f[R], \f[V]$\[at]\f[R]).
.IP
.nf
\f[C]
func test_function {
    print \[dq]Hello $1\[dq]
}
\f[R]
.fi
.SS USAGE
.PP
Once defined, custom functions can be called inside any other function
block (\f[V]build\f[R], \f[V]prepare\f[R], \f[V]package\f[R], etc.)
by simply typing their name and arguments.
.IP
.nf
\f[C]
build {
    test_function \[dq]Kreato\[dq]
}
\f[R]
.fi
.SS SCOPE AND VARIABLES
.IP \[bu] 2
Global Variables: Custom functions can access (and modify using the
\f[V]global\f[R] keyword) all variables defined in the YAML header.
This way you can create subpackages that have different properties to
the main package.
.IP \[bu] 2
Local Variables: You can define local variables inside a function using
the \f[V]local\f[R] keyword to prevent exposing them to the rest of the
script.
.IP \[bu] 2
Environment Variables: You can define environment variables inside a
function using the \f[V]env\f[R] keyword to pass that automatically.
.IP
.nf
\f[C]
func test_variables {
    local awesome=\[dq]yes!\[dq]
    global name=\[dq]test2\[dq]
    env EXAMPLE=\[dq]test\[dq]
    print \[dq]Is this local? $awesome\[dq]
    print \[dq]The package is named: $name\[dq]
    exec \[dq]echo you know this is a \[rs]$EXAMPLE right?\[dq]
}
\f[R]
.fi
.SH NAMING CONVENTIONS
.PP
Kongue variables are case-insensitive and support multiple naming
styles: * camelCase (e.g., \f[V]buildDepends\f[R]) * PascalCase (e.g.,
\f[V]BuildDepends\f[R]) * kebab-case (e.g., \f[V]build-depends\f[R]) *
snake_case (e.g., \f[V]build_depends\f[R])
.PP
snake_case is recommended for most scripts.
.PP
\f[B]Important\f[R]: Functions are case-sensitive and do not support
this flexibility.
.SH AUTHOR
.PP
Written by Kreato.
.SH COPYRIGHT
.PP
Kreato Linux src is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.
.PP
Kreato Linux src is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License along
with Kreato Linux src.
If not, see <https://www.gnu.org/licenses/>.
