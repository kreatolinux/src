.\" Automatically generated by Pandoc 3.1.3
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "kpkg_run" "5" "" "" ""
.hy
.SH NAME
.PP
kpkg runfile - Main package format of kpkg
.SH DESCRIPTION
.PP
kpkg runfiles are the main package format of kpkg.
They are basic scripts with specific variables and functions that enable
kpkg to build packages.
.SH RUNFILE STRUCTURE
.PP
Runfiles are simply named \f[V]run3\f[R] and must be placed inside the
package directory.
It is a specialized custom format.
.SS Example Runfile
.IP
.nf
\f[C]
name: \[dq]test-v3\[dq]
version: \[dq]0.0.1\[dq]
release: \[dq]1\[dq]
sources: 
    - \[dq]https://test.file/source/testfile.tar.gz\[dq]
    - \[dq]git::https://github.com/kreatolinux/src::543ee30eda806029fa9ea16a1f9767eda7cab4d1\[dq]
    - \[dq]https://test.file/sources/v${version.split(\[aq].\[aq])[0:2].join(\[aq].\[aq])}/testfile.tar.gz\[dq]
depends: 
    - \[dq]testpackage1\[dq] 
    - \[dq]testpackage3\[dq] 
    - \[dq]testpackage4\[dq]
depends_test2: 
    - \[dq]testpackage5\[dq] 
    - \[dq]testpackage6\[dq]
no_chkupd: false
replaces: 
    - \[dq]test-v2\[dq]
backup: 
    - \[dq]etc/test-v3/main.conf\[dq]
    - \[dq]etc/test/settings.conf\[dq]
opt_depends:
    - \[dq]optional-dependency: This is a test optional dependency\[dq]
    - \[dq]optional-dependency-2: This is a second optional dependency.\[dq]
build_depends: 
    - \[dq]testpackage5\[dq] 
    - \[dq]testpackage6\[dq] 
    - \[dq]testpackage10\[dq]
sha256sum: 
    - \[dq]e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\[dq]
    - \[dq]SKIP\[dq]
    - \[dq]ab37404db60460d548e22546a83fda1eb6061cd8b95e37455149f3baf6c5fd38\[dq]
sha512sum:
    - \[dq]cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\[dq] 
    - \[dq]SKIP\[dq]  
    - \[dq]fce866720603d30cbefe5c0df9c6bacf70cbdb27caef5bcf15f125901cb23a9681ec9f87410a7d2f763af5a89c2b4e43685196ce3b0674868bf81cb3688e47c8\[dq]
b2sum: 
    - \[dq]786a02f742015903c6c6fd852552d272912f4740e15847618a86e217f71f5419d25e1031afee585313896444934eb04b903a685b1448b755d56f701afe9be2ce\[dq]
    - \[dq]SKIP\[dq] 
    - \[dq]64fed8bce19ef14ed2d8434229dc2ec5307e06205610b1859b81b8090ae5ba7001988de896ff4878a15a7b7334e4a06e5889270b2e755fe130f7c80960e66ba2\[dq]
description: \[dq]Test package\[dq]

func custom_func {
    print \[dq]This is a test custom function\[dq]
}

prepare {
    custom_func # We can run custom functions just like commands
    env TEST=1
    exec tar -xvf testfile.tar.gz
    # Or you can use:
    # macro extract --autocd=true
    # to extract all the archives in sources.
}

build {
    cd testfile
    echo \[dq]Insert build instructions here\[dq]
}

check {
    macro test --ninja
    # exec ninja -C build test
}

preupgrade {
    echo \[dq]run before upgrade\[dq]
}

preinstall {
    echo \[dq]run before first install\[dq]
}

package {
    cd testfile
    macro package --meson
}

package_test2 {
    cd testfile
    exec make install_test2 # External commands require exec
}

postinstall {
    echo \[dq]Insert postinstall instructions here\[dq]
}

postupgrade {
    echo \[dq]run after upgrade\[dq]
}

postremove {
    echo \[dq]Insert postremove instructions here\[dq]
}
\f[R]
.fi
.SH SYNTAX AND LANGUAGE FEATURES
.SS VARIABLES
.PP
Variables must be declared at the top of the runfile.
They can be any type (list, string, int, bool, etc.).
Variables can be referenced in if statements, for loops, and inside
functions.
On commands, simple referencing is done via \f[V]$variable\f[R] or
\f[V]${variable}\f[R].
Complex manipulation (splitting, slicing) works via
\f[V]${variable.method()}\f[R] (or \f[V]variable.method()\f[R] on a
non-command context) (see \f[B]VARIABLE MANIPULATION\f[R] below).
.IP
.nf
\f[C]
test1: true
test2:
    - this is a test
    - test2
# and so on...
\f[R]
.fi
.PP
Variables can be referenced in if statements, for loops, inside
variables, and inside functions (including in macros and exec commands).
.IP
.nf
\f[C]
test1: true

# Additional stuff...

echo $test1
# Result: true
\f[R]
.fi
.PP
List variables can be filtered using \f[V][start:end]\f[R] and can be
indexed using \f[V][index]\f[R].
Note that this cannot be used with the \f[V]$variable\f[R] syntax, only
inside \f[V]${variable}\f[R].
See the example below.
.IP
.nf
\f[C]
test2:
    - IGNORE1
    - IGNORE2
    - IGNORE3

echo ${test2[0:3].join(\[aq]\[aq])}
# Result: IGNORE1IGNORE2IGNORE3

echo ${test2[0]}
# Result: IGNORE1
\f[R]
.fi
.SS IF ELSE STATEMENTS
.PP
If-else statements can be used inside all functions.
You can utilize all variables defined in the runfile.
.IP
.nf
\f[C]
build {
    if test1 {
        print hello!
    } else {
        print bye!
    }
}   
\f[R]
.fi
.PP
You can also use any variable manipulation methods in if statements,
including inline exec to execute commands and use their output or exit
code in conditions.
See \f[B]VARIABLE MANIPULATION\f[R] for details on available methods.
.SS VARIABLE MANIPULATION
.PP
Variables can be manipulated directly within strings using object-style
methods.
This is particularly useful for constructing source URLs that require
specific version formatting (e.g., extracting \[lq]Major.Minor\[rq] from
a full version string).
You can also use inline exec to execute commands and use their output or
exit code.
.PP
The syntax for manipulation is \f[V]${variable.method(arguments)}\f[R]
or \f[V]${exec(\[dq]command\[dq]).method()}\f[R].
.PP
\f[B]Note\f[R]: Global variables (defined at the top of the runfile)
cannot use exec directly.
Exec can only be used within function blocks (like \f[V]build\f[R],
\f[V]prepare\f[R], \f[V]package\f[R], etc.)
or inside custom functions.
.SS AVAILABLE METHODS
.IP \[bu] 2
\f[B]join(delimiter)\f[R] Joins a list into a string using the given
delimiter.
Only works with lists.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]2.78.1\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq]).join(\[aq]!\[aq])}\f[R] returns
\f[V]2!78!1\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[0:2].join(\[aq].\[aq])}\f[R] returns
\f[V]2.78\f[R]
.RE
.IP \[bu] 2
\f[B]split(delimiter)\f[R] Splits the string by the given delimiter and
returns the segments as a list.
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]2.78.1\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[0]}\f[R] returns \f[V]2\f[R]
.IP \[bu] 2
\f[V]${version.split(\[aq].\[aq])[1]}\f[R] returns \f[V]78\f[R]
.RE
.IP \[bu] 2
\f[B]cut(start, end)\f[R] Slices the string from the \f[V]start\f[R]
index up to (but not including) the \f[V]end\f[R] index.
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]commit: \[dq]543ee30eda80...\[dq]\f[R]
.IP \[bu] 2
\f[V]${commit.cut(0, 7)}\f[R] returns \f[V]543ee30\f[R]
.RE
.IP \[bu] 2
\f[B]replace(old, new)\f[R] Replaces all occurrences of \f[V]old\f[R]
substring with \f[V]new\f[R].
Only works with strings.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R] \f[V]version: \[dq]1.0.5\[dq]\f[R]
.IP \[bu] 2
\f[V]${version.replace(\[aq].\[aq], \[aq]_\[aq])}\f[R] returns
\f[V]1_0_5\f[R]
.RE
.IP \[bu] 2
\f[B]exec(command).output()\f[R] Executes a shell command and returns
its output.
Can be used in conditionals, variable assignments, and string
interpolation.
Only works within function blocks, not in global variable definitions.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R]
\f[V]build { if ${exec(\[dq]test -f config.h\[dq])}.output() { print \[dq]config.h exists\[dq] } }\f[R]
.IP \[bu] 2
\f[V]${exec(\[dq]ls -1 | head -n 1\[dq])}.output()\f[R] returns the
first line of directory listing
.RE
.IP \[bu] 2
\f[B]exec(command).exit()\f[R] Executes a shell command and returns its
exit code (0 for success, non-zero for failure).
Can be used in conditionals and comparisons.
Only works within function blocks, not in global variable definitions.
.RS 2
.IP \[bu] 2
\f[I]Example:\f[R]
\f[V]build { if ${exec(\[dq]test -f config.h\[dq])}.exit() == 0 { print \[dq]config.h exists\[dq] } }\f[R]
.IP \[bu] 2
\f[V]${exec(\[dq]ls nonexistent\[dq])}.exit()\f[R] returns a non-zero
exit code if the file doesn\[cq]t exist
.RE
.SS EXAMPLES
.PP
Combining methods to construct complex URLs:
.IP
.nf
\f[C]
version: \[dq]2.78.1\[dq]
sources:
    - \[dq]https://download.acme.org/sources/acme/${version.split(\[aq].\[aq])[0:2].join(\[aq].\[aq])}/acme-$version.tar.xz\[dq]
\f[R]
.fi
.PP
Using inline exec in conditionals and variable assignments:
.IP
.nf
\f[C]
build {
    if ${exec(\[dq]test -f config.h\[dq])}.exit() == 0 {
        print \[dq]config.h exists\[dq]
    }
    
    local first_file = ${exec(\[dq]ls -1 | head -n 1\[dq])}.output()
    print \[dq]First file: $first_file\[dq]
}
\f[R]
.fi
.SS FOR LOOPS
.PP
For loops can be used inside all functions.
You can access all variables defined in the runfile.
.IP
.nf
\f[C]
build {
    for i in test2 {
        print $i
    }
}
\f[R]
.fi
.SS BUILTIN COMMANDS
.PP
These are the built-in commands available in the runfile environment:
.IP \[bu] 2
\f[B]exec\f[R]: Spawn shell commands.
Usage: \f[V]exec [COMMAND]\f[R]
.IP \[bu] 2
\f[B]macro\f[R]: Use macros specifically made for extracting, building,
packaging, and testing packages.
Supported build systems include cmake, ninja, meson, and GNU Automake.
Usage: \f[V]macro [NAME] [FLAGS]\f[R]
.IP \[bu] 2
\f[B]print\f[R]: Print output to stdout.
Usage: \f[V]print [STRING]\f[R]
.IP \[bu] 2
\f[B]cd\f[R]: Change directory.
Usage: \f[V]cd [DIRECTORY]\f[R]
.IP \[bu] 2
\f[B]echo\f[R]: Alias to \f[V]print\f[R].
Usage: \f[V]echo [STRING]\f[R]
.IP \[bu] 2
\f[B]local\f[R]: Allows you to set a local variable inside a function
(see CUSTOM FUNCTIONS).
Usage: \f[V]local [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]global\f[R]: Allows you to set and override a global variable
inside a function (see CUSTOM FUNCTIONS).
Usage: \f[V]global [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]env\f[R]: Allows you to set and override environment variables
inside a function.
Usage: \f[V]env [VAR]=[VALUE]\f[R]
.IP \[bu] 2
\f[B]write\f[R]: Write content to a file.
Overwrites the file if it exists.
Usage: \f[V]write [FILE] [STRING]\f[R]
.IP \[bu] 2
\f[B]append\f[R]: Append content to a file.
Creates the file if it does not exist.
Usage: \f[V]append [FILE] [STRING]\f[R]
.PP
See \f[B]STRINGS\f[R] for information on multi-line content.
.PP
The rest of the shell commands (should you need them) can only be
accessed using the \f[V]exec\f[R] parameter.
.SS STRINGS
.PP
Strings can be enclosed in double quotes (\f[V]\[dq]\f[R]) or single
quotes (\f[V]\[aq]\f[R]).
.PP
For multi-line strings, use triple quotes (\f[V]\[dq]\[dq]\[dq]\f[R]).
.IP
.nf
\f[C]
write \[dq]file.txt\[dq] \[dq]\[dq]\[dq]
Line 1
Line 2
\[dq]\[dq]\[dq]
\f[R]
.fi
.SH VARIABLES AND FUNCTIONS
.SS CUSTOM FUNCTIONS
.PP
Users can define their own reusable functions to avoid repetition.
These function blocks follow the same syntax as lifecycle functions
(like \f[V]build\f[R] or \f[V]prepare\f[R]) but require the
\f[V]func\f[R] keyword.
.SS SYNTAX
.PP
Custom functions are defined at the top level of the runfile.
They use standard POSIX-like shell argument handling (\f[V]$1\f[R],
\f[V]$2\f[R], \f[V]$\[at]\f[R]).
.IP
.nf
\f[C]
func test_function {
    print \[dq]Hello $1\[dq]
}
\f[R]
.fi
.SS USAGE
.PP
Once defined, custom functions can be called inside any other function
block (\f[V]build\f[R], \f[V]prepare\f[R], \f[V]package\f[R], etc.)
by simply typing their name and arguments.
.IP
.nf
\f[C]
build {
    test_function \[dq]Kreato\[dq]
}
\f[R]
.fi
.SS SCOPE AND VARIABLES
.IP \[bu] 2
Global Variables: Custom functions can access (and modify using the
\f[V]global\f[R] keyword) all variables defined in the YAML header.
This way you can create subpackages that have different properties to
the main package.
.IP \[bu] 2
Local Variables: You can define local variables inside a function using
the \f[V]local\f[R] keyword to prevent exposing them to the rest of the
script.
.IP
.nf
\f[C]
func test_variables {
    local awesome=\[dq]yes!\[dq]
    global name=\[dq]test2\[dq]
    print \[dq]Is this local? $awesome\[dq]
    print \[dq]The package is named: $name\[dq]
}
\f[R]
.fi
.SS REQUIRED VARIABLES
.IP \[bu] 2
\f[B]name\f[R]: Name of your package.
Displayed in info command output.
.IP \[bu] 2
\f[B]version\f[R]: Version of your package.
Displayed in info command output.
Updating this will trigger package upgrade.
.IP \[bu] 2
\f[B]release\f[R]: Release number of your package.
Displayed in info command output.
Updating this will trigger package upgrade.
.IP \[bu] 2
\f[B]description\f[R]: Description of the package.
Displayed in info command output.
.SS REQUIRED FUNCTIONS
.IP \[bu] 2
\f[B]package\f[R]: The installation function that defines how the
package should be installed.
.SS SOURCE AND DEPENDENCY VARIABLES
.IP \[bu] 2
\f[B]sources\f[R]: Source URLs of your package.
Can be specified as a list.
Supports git URLs as shown in the example.
.IP \[bu] 2
\f[B]depends\f[R]: Runtime dependencies of your package.
Supports version specifications like:
.RS 2
.IP \[bu] 2
\f[V]test<=1.8.1\f[R]: Less than or equal to version 1.8.1
.IP \[bu] 2
\f[V]test=1.8.1\f[R]: Exactly version 1.8.1
.IP \[bu] 2
\f[V]test>=1.8.1\f[R]: Greater than or equal to version 1.8.1
.IP \[bu] 2
\f[V]test<1.8.1\f[R]: Less than version 1.8.1
.IP \[bu] 2
\f[V]test>1.8.1\f[R]: Greater than version 1.8.1
.RE
.IP \[bu] 2
\f[B]build_depends\f[R]: Build-time dependencies of your package.
.IP \[bu] 2
\f[B]depends_packagename\f[R]: Specify dependencies for a specific
sub-package.
Can be modified using:
.RS 2
.IP \[bu] 2
\f[V]depends_packagename+: \[dq]packagename\[dq]\f[R] to add a
dependency
.IP \[bu] 2
\f[V]depends_packagename-: \[dq]packagename\[dq]\f[R] to remove a
dependency
.IP \[bu] 2
\f[V]depends_packagename: \[dq]packagename\[dq]\f[R] to replaces
dependencies completely
.RE
.SS CHECKSUM VARIABLES
.IP \[bu] 2
\f[B]sha256sum\f[R]: SHA-256 checksums of the sources.
Should align with the sources in order.
.IP \[bu] 2
\f[B]sha512sum\f[R]: SHA-512 checksums of the sources.
Should align with the sources in order.
.IP \[bu] 2
\f[B]b2sum\f[R]: BLAKE2 checksums of the sources.
Should align with the sources in order.
.PP
Do mind that Git repositories don\[cq]t have the checksum ability.
You can use \f[V]SKIP\f[R] for git sources as this value is ignored.
.SS OPTIONAL VARIABLES
.IP \[bu] 2
\f[B]epoch\f[R]: Only use when versioning logic fails for the package.
.IP \[bu] 2
\f[B]no_chkupd\f[R]: Disables auto-updating through chkupd.
Default is \f[V]false\f[R].
.IP \[bu] 2
\f[B]replaces\f[R]: Specifies packages that this package replaces.
.IP \[bu] 2
\f[B]opt_depends\f[R]: Optional dependencies for the package, with
description after colon.
.IP \[bu] 2
\f[B]conflicts\f[R]: Specifies packages that conflict with this package.
.IP \[bu] 2
\f[B]is_group\f[R]: Indicates if the package is a group package.
Default is \f[V]false\f[R].
.IP \[bu] 2
\f[B]backup\f[R]: Preserves files (such as configuration files) during
upgrades.
Don\[cq]t include leading slash (use \f[V]etc/bluetooth/main.conf\f[R]
instead of \f[V]/etc/bluetooth/main.conf\f[R]).
.SS OPTIONAL FUNCTIONS
.IP \[bu] 2
\f[B]build\f[R]: Main build function.
Only optional for packages that don\[cq]t need to be built (e.g.,
binary-only packages).
.IP \[bu] 2
\f[B]prepare\f[R]: Custom preparation procedure.
Files from sources are extracted by default unless this function is
defined.
.IP \[bu] 2
\f[B]check\f[R]: Function to test the package.
.IP \[bu] 2
\f[B]preinstall\f[R]: Runs when the package is installed for the first
time (not during upgrades).
.IP \[bu] 2
\f[B]postinstall\f[R]: Runs after the package is installed.
.IP \[bu] 2
\f[B]preupgrade\f[R]: Runs before an upgrade occurs.
.IP \[bu] 2
\f[B]postupgrade\f[R]: Runs after an upgrade completes.
.IP \[bu] 2
\f[B]postremove\f[R]: Runs after the package is removed.
.IP \[bu] 2
\f[B]package_packagename\f[R]: Installation function for a sub-package.
Allows packaging multiple components in the same runfile.
.SH NAMING CONVENTIONS
.PP
Runfile variables are case-insensitive and support multiple naming
styles: * camelCase (e.g., \f[V]buildDepends\f[R]) * PascalCase (e.g.,
\f[V]BuildDepends\f[R]) * kebab-case (e.g., \f[V]build-depends\f[R]) *
snake_case (e.g., \f[V]build_depends\f[R])
.PP
snake_case is recommended for most runfiles.
.PP
\f[B]Important\f[R]: Functions are case-sensitive and do not support
this flexibility.
.SH AUTHOR
.PP
Written by Kreato.
.SH COPYRIGHT
.PP
kpkg is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.
.PP
kpkg is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License along
with kpkg.
If not, see <https://www.gnu.org/licenses/>.
